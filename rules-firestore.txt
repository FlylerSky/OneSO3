rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ===============================================
    // POSTS COLLECTION
    // ===============================================
    match /posts/{postId} {
      // Public read
      allow read: if true;

      // Create: authenticated users may create posts (userId must match) OR anonymous allowed (legacy)
      allow create: if
        request.resource.data.createdAt == request.time
        && request.resource.data.likes == 0
        && request.resource.data.dislikes == 0
        && request.resource.data.commentsCount == 0
        && (
          (request.auth != null && request.resource.data.userId == request.auth.uid)
          || (request.auth == null)
        );

      // Delete: only owner
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;

      // Update:
      // - Owner can update post content (not reaction/comment counters)
      // - Authenticated users may change reaction counters and commentsCount in controlled ±1 steps
      allow update: if (
        // owner editing content (must not change counters)
        (request.auth != null
          && resource.data.userId == request.auth.uid
          && request.resource.data.createdAt == resource.data.createdAt
          && request.resource.data.userId == resource.data.userId
          && !request.resource.data.diff(resource.data).changedKeys().hasAny(['likes','dislikes','commentsCount'])
        )
        ||
        // controlled counter-only updates by authenticated users
        (
          request.auth != null
          && request.resource.data.diff(resource.data).changedKeys().hasOnly(['likes','dislikes','commentsCount'])
          && request.resource.data.likes is int
          && request.resource.data.dislikes is int
          && request.resource.data.commentsCount is int
          // allow counters to stay same or change by ±1
          && (
            request.resource.data.likes == resource.data.likes
            || request.resource.data.likes == resource.data.likes + 1
            || request.resource.data.likes == resource.data.likes - 1
          )
          && (
            request.resource.data.dislikes == resource.data.dislikes
            || request.resource.data.dislikes == resource.data.dislikes + 1
            || request.resource.data.dislikes == resource.data.dislikes - 1
          )
          && (
            request.resource.data.commentsCount == resource.data.commentsCount
            || request.resource.data.commentsCount == resource.data.commentsCount + 1
            || request.resource.data.commentsCount == resource.data.commentsCount - 1
          )
        )
      );

      // ===============================================
      // COMMENTS SUBCOLLECTION (v1.5 UPDATED)
      // ===============================================
      match /comments/{commentId} {
        allow read: if true;

        // Create: only authenticated users, userId must match auth.uid, createdAt must be server time
        allow create: if request.auth != null
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.displayName is string
                      && request.resource.data.text is string
                      && request.resource.data.createdAt == request.time;

        // Update: FOUR scenarios allowed
        allow update: if (
          // 1️⃣ Owner editing their comment (text, mentions, editedAt, editCount) - v1.5 NEW
          (request.auth != null
            && resource.data.userId == request.auth.uid
            && request.resource.data.diff(resource.data)
               .changedKeys()
               .hasOnly(['text', 'mentions', 'editedAt', 'editCount'])
          )
          ||
          // 2️⃣ Owner updating displayName (profile name propagation)
          (request.auth != null
            && resource.data.userId == request.auth.uid
            && request.resource.data.displayName is string
            && request.resource.data.diff(resource.data)
               .changedKeys()
               .hasOnly(['displayName'])
          )
          ||
          // 3️⃣ Any authenticated user incrementing reportCount by +1 - v1.5 NEW
          (request.auth != null
            && request.resource.data.diff(resource.data)
               .changedKeys()
               .hasOnly(['reportCount'])
            && request.resource.data.reportCount is int
            && (
              // Allow increment by 1 if field exists
              (resource.data.keys().hasAll(['reportCount']) 
                && request.resource.data.reportCount == resource.data.reportCount + 1)
              // OR initialize to 1 if field doesn't exist
              || (!resource.data.keys().hasAll(['reportCount']) 
                && request.resource.data.reportCount == 1)
            )
          )
        );

        // Delete: allow comment owner to delete their own comment
        allow delete: if request.auth != null 
                      && resource.data.userId == request.auth.uid;

        // ===============================================
        // REPORTS SUBCOLLECTION (v1.5 NEW)
        // ===============================================
        match /reports/{reporterId} {
          // Read: No one can read reports list (privacy)
          allow read: if false;

          // Create: Authenticated user can create report with their own ID
          allow create: if request.auth != null
                        && request.auth.uid == reporterId
                        && request.resource.data.userId == request.auth.uid
                        && request.resource.data.reason is string
                        && request.resource.data.reason in ['spam', 'offensive', 'inappropriate', 'other']
                        && request.resource.data.createdAt == request.time;

          // Update/Delete: Reports cannot be modified or deleted
          allow update: if false;
          allow delete: if false;
        }
      }

      // ===============================================
      // LIKES SUBCOLLECTION
      // ===============================================
      match /likes/{likeId} {
        allow read: if true;
        
        // Create: auth user may create a like/dislike doc whose id equals their uid
        allow create: if request.auth != null
                      && request.auth.uid == likeId
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.type in ['like','dislike']
                      && request.resource.data.createdAt == request.time;
        
        // Update: owner may flip type
        allow update: if request.auth != null
                      && request.auth.uid == likeId
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.type in ['like','dislike'];
        
        // Delete: owner may delete their like doc
        allow delete: if request.auth != null && request.auth.uid == likeId;
      }
    }

    // ===============================================
    // USERS COLLECTION
    // ===============================================
    match /users/{userId} {
      allow read: if true;

      // Create: signup only by authenticated user with matching uid and email
      allow create: if request.auth != null
                    && request.auth.uid == userId
                    && request.resource.data.email == request.auth.token.email;

      // Update: owner may update their full profile
      // OR controlled adjustments to followersCount/followingCount by ±1 (including case where field missing -> set to 1)
      allow update: if (
        request.auth != null && request.auth.uid == userId
      ) || (
        request.auth != null
        && request.resource.data.diff(resource.data).changedKeys().hasOnly(['followersCount','followingCount'])
        && (
          // followersCount: either unchanged OR ±1 if exists OR set to 1 if missing
          (
            (resource.data.followersCount is int && (
               request.resource.data.followersCount == resource.data.followersCount
               || request.resource.data.followersCount == resource.data.followersCount + 1
               || request.resource.data.followersCount == resource.data.followersCount - 1
            ))
            || (!resource.data.keys().hasAll(['followersCount']) && request.resource.data.followersCount == 1)
          )
        )
        && (
          // followingCount: either unchanged OR ±1 if exists OR set to 1 if missing
          (
            (resource.data.followingCount is int && (
               request.resource.data.followingCount == resource.data.followingCount
               || request.resource.data.followingCount == resource.data.followingCount + 1
               || request.resource.data.followingCount == resource.data.followingCount - 1
            ))
            || (!resource.data.keys().hasAll(['followingCount']) && request.resource.data.followingCount == 1)
          )
        )
      );

      // Delete: only owner
      allow delete: if request.auth != null && request.auth.uid == userId;

      // ===============================================
      // FOLLOWERS SUBCOLLECTION
      // ===============================================
      match /followers/{followerId} {
        allow read: if true;
        allow create: if request.auth != null
                      && request.auth.uid == followerId
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.createdAt == request.time;
        allow delete: if request.auth != null && request.auth.uid == followerId;
        allow update: if false;
      }

      // ===============================================
      // FOLLOWING SUBCOLLECTION
      // ===============================================
      match /following/{followingId} {
        allow read: if true;
        allow create: if request.auth != null
                      && request.auth.uid == userId
                      && request.resource.data.userId == followingId
                      && request.resource.data.createdAt == request.time;
        allow delete: if request.auth != null && request.auth.uid == userId;
        allow update: if false;
      }

      // ===============================================
      // VISITORS SUBCOLLECTION
      // ===============================================
      match /visitors/{visitorId} {
        // visitors list readable only by profile owner
        allow read: if request.auth != null && request.auth.uid == userId;

        // visitor may create/update their own visitor doc (lastVisitedAt must be server time)
        allow create, update: if request.auth != null
                               && request.auth.uid == visitorId
                               && request.resource.data.userId == request.auth.uid
                               && request.resource.data.lastVisitedAt == request.time;

        // delete only by owner or visitor
        allow delete: if request.auth != null && (request.auth.uid == userId || request.auth.uid == visitorId);
      }
    }

    // ===============================================
    // SEARCH STATS
    // ===============================================
    match /searchStats/{doc} {
      allow read: if true;
      allow write: if true;
    }
  }
}